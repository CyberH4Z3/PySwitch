class Controller {

    VERSION = "2.4.0.0";        // For productive releases, the first three numbers should always match the PySwitch version. The last is the UI version.

    ui = null;                  // User Interface implementation
    routing = null;

    pyswitch = null;            // PySwitch runner (in browser)
    device = null;              // Device handler (Controller, like Midi Captain)
    
    /**
     * Options:
     * {
     *     // UI options:
     *     containerElementSelector: "body",       DOM Selector for the container DOM element the ui should be built in 
     *                                             (optional, default: "body")
     * 
     *     // Python options:
     *     domNamespace: "pyswitch",               ID prefix for access to DOM elements from Python code. All elements generated by python code will 
     *                                             be prefixed with this. Optional, default is "pyswitch".
     *                                             Explanation: Python code searches its elements via ID selectors. To avoid conflicts, this option has to be present.
     * 
     *     updateIntervalMillis: 20,               Tick interval in milliseconds. On CircuitPython, the program does as much ticks as it can (in a while True loop),
     *                                             which in a browser woult block all user interaction, so the ticks are triggered in intervals. Optional, default is 20.
     * }
     */
    constructor(options = {}) {
        // Defaults
        if (!options.containerElementSelector) {
            options.containerElementSelector = "body";
        }
        if (!options.domNamespace) {
            options.domNamespace = "pyswitch";
        }
        if (!options.updateIntervalMillis) {
            options.updateIntervalMillis = 20;
        }

        // Set up handlers
        this.ui = new PySwitchUI(this, options);
        this.pyswitch = new PySwitchRunner(options, options.domNamespace + "-device");    
        this.device = new PySwitchDevice(this);
    }

    /**
     * Run the app.
     */
    async run() {
        // Initialize the device (this also sets up Web MIDI which the UI is reusing)
        await this.device.init();

        // Initialize UI (settings panel etc.)        
        await this.ui.build();

        // Routing handler
        this.routing = new Routing(this);

        // Run routing
        this.routing.run();
    }

    /**
     * Handle exceptions
     */
    handle(e) {
        this.ui.message(e, "E");
        //this.routing.home();
    }

    /**
     * Scans for controllers and hook up to the first one found
     */
    async scan() {
        console.log("Scanning ports...");

        // Scan and open root folder of first found bridge.
        await this.#scanAndOpenFirst();
    }

    /**
     * Run PySwitch with a specific configuration.
     */
    async loadConfiguration(config) {
        // if (config instanceof ControllerConfiguration) {
        //     this.ui.selectController.val(config.name);
        // } else {
        //     this.ui.selectController.val("Not connected");
        // }

        this.ui.progress(0.3, "Initialize Pyodide");

        // Initialize PySwitch (this starts Pyodide and copies all necessary sources to the Emscripten virtual file system)
        await this.pyswitch.init();

        this.ui.progress(0.5, "Load configuration");

        // Load config
        await config.load();

        this.ui.setHeadline(config.headline());

        this.ui.progress(0.8, "Run PySwitch");

        // Run local PySwitch with local config "files"
        await this.pyswitch.run(config.inputs_py, config.display_py);
        this.ui.message("Loaded configuration: " + config.name, "S");

        this.ui.progress(1);
    }

    /**
     * If the path contains a valid example, run it. If not, show the contents of path.
     */
    async loadExample(path) {        
        const config = new WebConfiguration("examples/" + encodeURI(path));
            
        try {
            console.info("If any 404 errors come up now, this is normal and tells the application to browse the contents of the example path.");

            // Try to load
            await config.load();

            this.ui.setHeadline(config.headline());
            
            // Successful: Keep it
            await this.loadConfiguration(config);

        } catch(e) {
            if (e.message.includes("Error fetching")) {
                // No configuration found: Show browser
                await this.ui.browseExample(path);    
            } else {
                // Error
                throw e;
            }
        }
    }

    /**
     * Triggered on client selector change
     */
    selectClient(portName) {
        // First throw out the MIDI wrapper already active
        this.pyswitch.setMidiWrapper(
            new DummyMidiWrapper()
        );

        // Search for the ports
        const port = this.device.getPortPair(portName);       
        if (!port) {
            this.ui.message("No client device connected", "I");
            return;
        }

        this.pyswitch.setMidiWrapper(                    
            new WebMidiWrapper(port.input, port.output)
        );

        this.ui.message("Connected to client at " + port.name, "S");
    }

    /**
     * Triggered on controller selector change
     */
    selectController(portName) {
        this.routing.call(this.getControllerUrl(portName));
    }

    /**
     * Scan ports and open the first one
     */
    async #scanAndOpenFirst() {
        const that = this;
        await this.device.bridge.scan(function(data) {
            setTimeout(function() {
                that.routing.call(that.getControllerUrl(data.name));
            }, 0);
            return true
        });
    }

    /**
     * Returns a href for the passed path on the current port
     */
    getControllerUrl(portName) {
        if (!portName) portName = this.device.portName();
        return encodeURI("controller/" + portName);
    }
}