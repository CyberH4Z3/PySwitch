class Controller {

    VERSION = "2.4.0.1";        // For productive releases, the first three numbers should always match the PySwitch version. The last is the UI version.

    ui = null;                  // User Interface implementation
    routing = null;             // sammy.js router

    midi = null;                // MIDI handler
    device = null;              // Device handler (Controller, like Midi Captain)
    client = null;              // Client handler (like Kemper Player)
    pyswitch = null;            // PySwitch runner (in browser)

    currentConfig = null;
    
    /**
     * Options:
     * {
     *     // UI options:
     *     containerElementSelector: "body",       DOM Selector for the container DOM element the ui should be built in 
     *                                             (optional, default: "body")
     * 
     *     // Python options:
     *     domNamespace: "pyswitch",               ID prefix for access to DOM elements from Python code. All elements generated by python code will 
     *                                             be prefixed with this. Optional, default is "pyswitch".
     *                                             Explanation: Python code searches its elements via ID selectors. To avoid conflicts, this option has to be present.
     * 
     *     updateIntervalMillis: 20,               Tick interval in milliseconds. On CircuitPython, the program does as much ticks as it can (in a while True loop),
     *                                             which in a browser woult block all user interaction, so the ticks are triggered in intervals. Optional, default is 20.
     * }
     */
    constructor(options = {}) {
        // Defaults
        if (!options.containerElementSelector) {
            options.containerElementSelector = "body";
        }
        if (!options.domNamespace) {
            options.domNamespace = "pyswitch";
        }
        if (!options.updateIntervalMillis) {
            options.updateIntervalMillis = 20;
        }

        // Set up handlers
        this.ui = new PySwitchUI(this, options);

        this.midi = new MidiHandler();

        this.pyswitch = new PySwitchRunner(options, options.domNamespace + "-device");    
        this.device = new PySwitchDevice(this);
        this.client = new PySwitchClient(this);
    }

    /**
     * Run the app.
     */
    async run() {
        // Initialize MIDI
        await this.midi.init();

        // Initialize UI (settings panel etc.)        
        await this.ui.build();

        // Routing handler: Runs routing. see Routing.js for the callbacks which in turn call this controller again.
        this.routing = new Routing(this);
        this.routing.run();
    }

    /**
     * Handle exceptions
     */
    handle(e) {
        this.ui.message(e, "E");
        //this.routing.home();
    }

    /**
     * Scans for controllers and navigate to load its configuration
     */
    async scanControllers() {
        console.log("Scanning ports for MidiBridges...");

        const that = this;
        await this.device.scan(
            function(connection) {
                setTimeout(function() {
                    // Detach the bridge (scanning will just call a redirect which creates its own bridge)
                    that.device.bridge.detach(connection.bridge);

                    // Redirect to the found controller's URL
                    that.routing.call(that.getControllerUrl(connection.name));
                }, 0);
            }
        );
    }

    /**
     * Run PySwitch with a specific configuration.
     */
    async loadConfiguration(config) {
        this.currentConfig = null;

        this.ui.progress(0.1, "Initialize emulator");

        // Initialize PySwitch (this starts Pyodide and copies all necessary sources to the Emscripten virtual file system)
        await this.pyswitch.init();

        this.ui.progress(0.3, "Initialize client device");
        
        // Initialize client (scan for devices)
        await this.client.init(config);

        const that = this;
        this.pyswitch.setProtocolStateCallback(function(state) {
            switch(state) {
                case 10:  // Offline
                    break;
                case 20:  // Running
                    that.ui.clientButton.setState(ClientConnectionButton.STATE_CONNECTED);
                    break;
            }
        });

        this.ui.progress(0.5, "Load configuration");

        // Show name of config, CSS classes etc.
        await this.ui.applyConfig(config);

        this.ui.progress(0.8, "Run PySwitch");

        // Run local PySwitch with the config
        await this.pyswitch.run(await config.get());
        this.ui.message("Loaded configuration: " + config.name, "S");

        this.ui.progress(1);
        this.currentConfig = config;
    }

    /**
     * If the path contains a valid example, run it. If not, show the contents of path.
     */
    async loadExample(path) {        
        const config = new WebConfiguration("examples/" + encodeURI(path));
            
        try {
            console.info("If any 404 errors come up now, this is normal and tells the application to browse the contents of the example path.");

            await this.ui.applyConfig(config);
            
            // Successful: Keep it
            await this.loadConfiguration(config);

        } catch(e) {
            if (e.message.includes("Error fetching")) {
                // No configuration found: Show browser
                await this.ui.browseExample(path); 
                   
            } else {
                // Error
                throw e;
            }
        }
    }

    /**
     * Set a variable in local storage
     */
    setState(key, value) {
        const data = JSON.parse(localStorage.getItem("pyswitch") || "{}");
        data[key] = value;
        localStorage.setItem("pyswitch", JSON.stringify(data));
    }

    /**
     * Read local storage
     */
    getState(key) {
        const data = JSON.parse(localStorage.getItem("pyswitch") || "{}");
        if (!data || !data.hasOwnProperty(key)) return null;
        return data[key];
    }

    // /**
    //  * Triggered on controller selector change
    //  */
    // selectController(portName) {
    //     this.routing.call(this.getControllerUrl(portName));
    // }

    /**
     * Returns a href for the passed path on the current port
     */
    getControllerUrl(portName) {
        if (!portName) portName = this.device.portName();
        return encodeURI("controller/" + portName);
    }
}